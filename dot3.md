### 标题：详细说说 0.1 + 0.2 != 0.3
### 作者：子非
### 原文：https://github.com/liudongmiao/dot3/blob/master/dot3.md
### 简介：本文通过描述计算机中浮点数的存储，得出 0.1 并不是 0.1，0.2 也不是 0.2，当然 0.1 + 0.2 也不是 0.3。

几乎在每个计算机语言中，如果去算`0.1`+`0.2`，肯定不会得到`0.3`，甚至有个基于这个答案的域名网站。

要了解为什么`0.1` + `0.2`不等于`0.3`，就得回到小数的表示方法上来。在`Java`中，我们可以使用高精度的`BigDecimal`来查看实际的值：（其它语言可以更多精确下输出格式，比如`%0.100f`之类）

```java
import java.math.BigDecimal;

public class Dot3 {

  private static void dump(double d) {
    String s = new BigDecimal(d).toString();
    System.out.format("%s=%s%n", d, s);
  }

  public static void main(String[] args) {
    dump(0.1);
    dump(0.2);
    dump(0.3);
    System.out.println(0.1 + 0.2);
  }

}
```

运行之后，会输出以下结果：

> 0.1=0.1000000000 0000000555 1115123125 7827021181 5834045410 15625  
> 0.2=0.2000000000 0000001110 2230246251 5654042363 1668090820 3125  
> 0.3=0.2999999999 9999998889 7769753748 4345957636 8331909179 6875  
> 
> 0.3000000000 0000004

我们可以看到，`0.1`其实不是`0.1`，`0.2`也不是`0.2`，`0.3`更不是`0.3`。那么，当实际上的`0.1`+`0.2`之后，就只能得到`0.3000000000 0000001665 3345369377 3481063544 7502136230 46875`。可是，这个数也不是`0.3000000000 0000004`啊，到底出了什么问题呢？

这一切，得回到数在计算机中的表示中来。在计算机中，数都是以`2`进制存储的，我们可以得到`5`：

> 5<sub>10</sub> = 101<sub>2</sub>

这是因为，5 = 1 \* 2<sup>2</sup> + 1 \* 2<sup>0</sup>。同样，也可以求得小数`0.5`：

> 0.5<sub>10</sub> = 0.1<sub>2</sub>

这又是因为，`0.5` = 1 \* 2<sup>-1</sup>。类似的，为了求`0.1`，我们可以不断的乘以`2`:

> 0.1<sub>10</sub>, \* 2, 0.2<sub>10</sub> = 0  
> 0.2<sub>10</sub>, \* 2, 0.4<sub>10</sub> = 0  
> 0.4<sub>10</sub>, \* 2, 0.8<sub>10</sub> = 0  
> 0.8<sub>10</sub>, \* 2, 1.6<sub>10</sub> = 1 余 0.6  
> 0.6<sub>10</sub>, \* 2, 1.2<sub>10</sub> = 1 余 0.2，出现循环  

所以，0.1<sub>10</sub> = 0.0<span style="text-decoration: overline">0011</span><sub>2</sub>。同理，可以得到，0.2<sub>10</sub> = 0.<span style="text-decoration: overline">0011</span><sub>2</sub>，0.3<sub>10</sub> = 0.0<span style="text-decoration: overline">1001</span><sub>2</sub>。

实际上受精度控制，不能无限循环。在双精度中，存储有效位数是`52`，加上省去的`1`，实际上精度是`53`位。

我们先看看`0.1`，`x`(或`o`)表示精度位（下同）:

```
0.1 = 0.0001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 100x 1001 ....
    = 0.0001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1010
    = 0x1.999999999999ap-4 (Java 特有表示法)
    = 0.1000000000 0000000555 1115123125 7827021181 5834045410 15625
```

同理，`0.2`:

```
0.2 = 0.0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 00x1 0011 ....
    = 0.0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 0011 010
    = 0x1.999999999999ap-3 (Java 特有表示法)
    = 0.2000000000 0000001110 2230246251 5654042363 1668090820 3125 
```

相加以后：

```
 +  = 0.0100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1x10
    = 0.0100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1101 00
    = 0x1.3333333333334p-2 (Java 特有表示法)
    = 0.3000000000 0000004440 8920985006 2616169452 6672363281 25
````

而`0.3`为：

```
0.3 = 0.0100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1x00 1100 ....
    = 0.0100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 11
    = 0x1.3333333333333p-2 (Java 特有表示法)
    = 0.2999999999 9999998889 7769753748 4345957636 8331909179 6875
```

它们之间的差异，我们可以明显看出：

```
 δ  = 0.0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 01
    = 0x1p-54 (Java 特有表示法)
    = 0.0000000000 0000005551 1151231257 8270211815 8340454101 5625
```

再回过头来看之前所说的不一致问题，实际上，他们是同一个数：

```
= 0.3000000000 0000001665 3345369377 3481063544 7502136230 46875

= 0.0100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1x1
= 0.0100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1101 00

= 0.3000000000 0000004440 8920985006 2616169452 6672363281 25
```

但是，等等，既然`0.1`不是`0.1`，而是`0.1000000000 0000000555 1115123125 7827021181 5834045410 15625`，为什么显示`0.1`呢？如果真的想知道的话，请留言，下篇再说（呃，实际上，我也还没弄太明白）。

在本篇的末了，说下正确的计算`0.1` + `0.2`的方法。

```java
// Java
public static String add(String a, String b) {
    return new BigDecimal(a).add(new BigDecimal(b)).toString();
}
```

```python
# Python
from fractions import Fraction

def add(a, b):
    return float(Fraction(a) + Fraction(b))
```

至于其它语言，就得自己实现了，基本上是把整数与小数单独拆出来。再说个彩蛋，为什么大家喜欢`5.20`而不是`5.21`呢？可能因为：

> 5.20<sub>10</sub> = 101.0011 0011 0011 0011 .... <sub>2</sub>
